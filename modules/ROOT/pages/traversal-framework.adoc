:description: The Neo4j traversal framework Java API.

:org-neo4j-graphdb-Direction-both: {neo4j-javadocs-base-uri}/org/neo4j/graphdb/Direction.html#BOTH


[[traversal]]
= The traversal framework

This section provides an overview of the concepts of the traversal framework, and a detailed description of the Neo4j traversal framework Java API.

The Neo4j Traversal framework Java API is a callback-based, lazily-executed way of specifying desired movements through a graph in Java.
Some traversal examples are collected under xref:java-embedded/traversal.adoc[].

Although the traversal framework is less readable and more complex than the xref:5.0@cypher-manual:ROOT:index.adoc[Cypher query language], it
offers a powerful approach to traversing the graph. Being able to dynamically make custom choices at each step
of the traversal makes it more expressive and potentially more performant than Cypher.

[WARNING]
====
It is generally recommended to use Cypher wherever possible, but when using the Traversal Framework the following should be kept in mind:

Cypher uses memory tracking which allows a query to be aborted if it occupies too much memory,
but mixing in Traversal API via a function you may run out of memory if your Traversal uses a lot of memory.

Do not reuse objects fetched during a Traversal in another transaction.
====

== When to use the Traversal Framework instead of Cypher
* The Traversal Framework allows to use any desired java library to express the traversal.
* The Traversal Framework allows customized pruning while traversing a path, which can improve the performance of a traversal.
See <<traversal-java-api-evaluator, Evaluator>> for more information.
* In Cypher it's not possible to specify in which order paths are expanded (e.g. depth-first).
The Traversal Framework permits to specify the <<traversal-java-api-branchselector,order of traversing paths>>.
* In Cypher relationships are only traversed once (`RELATIONSHIP_GLOBAL` uniqueness).
The Traversal Framework permits to specify the <<traversal-java-api-uniqueness, uniqueness constraints of the path traversed>>.

[[traversal-concepts]]
== Main concepts

Below is a short explanation of all different methods that can modify or add to a traversal description.

* _Pathexpanders_ -- define what to traverse, typically in terms of relationship direction and type.
* _Order_ -- for example depth-first or breadth-first.
* _Uniqueness_ -- visit nodes (relationships, paths) only once.
* _Evaluator_ -- decide what to return and whether to stop or continue traversal beyond the current position.
* _Starting nodes_ where the traversal will begin.

image::graphdb-traversal-description.svg[role="middle"]


[[traversal-java-api]]
== Traversal framework Java API

The traversal framework consists of a few main interfaces in addition to `Node` and `Relationship`: `TraversalDescription`, `Evaluator`, `Traverser` and `Uniqueness` are the main ones.
The `Path` interface also has a special purpose in traversals, since it is used to represent a position in the graph when evaluating that position.
Furthermore, the `PathExpander` (replacing `RelationshipExpander` and `Expander`) interface is central to traversals, but users of the API rarely need to implement it.
There are also a set of interfaces for advanced use, when explicit control over the traversal order is required: `BranchSelector`, `BranchOrderingPolicy` and `TraversalBranch`.


[[traversal-java-api-traversaldescription]]
=== TraversalDescription

The `TraversalDescription` is the main interface used for defining and initializing traversals.
It is not meant to be implemented by users of the traversal framework, but rather to be provided by the implementation of the traversal framework as a way for the user to describe traversals.
`TraversalDescription` instances are immutable and its methods returns a new `TraversalDescription` that is modified compared to the object the method was invoked on with the arguments of the method.


==== Relationships

Adds a relationship type to the list of relationship types to traverse.
By default this list is empty and it means that it will traverse _all relationships_, regardless of type.
If one or more relationships are added to this list _only the added_ types will be traversed.
There are two methods, one `including direction` and another one `excluding direction`, where the latter traverses relationships in link:{org-neo4j-graphdb-Direction-both}[both directions^].


[[traversal-java-api-evaluator]]
=== Evaluator

`Evaluators` are used for deciding, at each position (represented as a `Path`) whether the traversal should continue, and/or whether the node should be included in the result.
Given a `Path`, it asks for one of four actions for that branch of the traversal:

* `Evaluation.INCLUDE_AND_CONTINUE`: Include this node in the result and continue the traversal.
* `Evaluation.INCLUDE_AND_PRUNE`: Include this node in the result, but do not continue the traversal.
* `Evaluation.EXCLUDE_AND_CONTINUE`: Exclude this node from the result, but continue the traversal.
* `Evaluation.EXCLUDE_AND_PRUNE`: Exclude this node from the result and do not continue the traversal.

More than one evaluator can be added.

[NOTE]
====
Evaluators will be called for all positions the traverser encounters, even for the start node.
====

==== Built-in Evaluators

The Framework also provides various built in evaluators such as:

* `Evaluators.all()`: Includes and continues on all nodes.
* `Evaluators.atDepth(int)`: Includes only paths at the given depth and prunes everything else.
* `Evaluators.toDepth(int)`: Includes paths up to the given depth and prunes everything deeper than that.
* `Evaluators.fromDepth(int)`: Includes paths from the given depth, ignoring those before and never prunes anything.
* `Evaluators.includingDepths(int, int)`: Includes only the paths equal to and between the 2 given depths.
* `Evaluators.lastRelationshipTypeIs(Evalutation, Evaluation, RelationshipType...)`: Allows the choice of which evaluation to take based on
whether the last relationship matches one of the given ones.
* `Evaluators.includeWhereLastRelationshipTypeIs(RelationshipType...)`: Only returns paths in which the final relationship matches the given ones.
* `Evaluators.endNodeIs(Evaluation, Evaluation, Node...)`: Allows the choice of which evaluation to take based on
whether the last node matches one of the given nodes.
* `Evaluators.includeIfContainsAll(Node...)`: Returns a path if all given nodes are contained within it.
* `Evaluators.includeIfAcceptedByAny(PathEvaluator)`: Returns a path if any of the given evaluators include the current path.
* `Evaluators.endNodeIsAtDepth(int, Node...)`: Returns a path if one of the given nodes is at the given depth.

[[traversal-java-api-traverser]]
=== Traverser

The `Traverser` object is the result of invoking `traverse()` of a `TraversalDescription` object.
It represents a traversal positioned in the graph, and a specification of the format of the result.
The actual traversal is performed lazily each time the `next()`-method of the iterator of the `Traverser` is invoked.

==== Example
Here is an example of a Traversal with default values (Uniqueness: NODE_GLOBAL, Expander: BOTH, Branch Ordering: PREORDER_DEPTH_FIRST):
[source, java]
----
TraversalDescription td;
try ( Transaction tx = graphDb.beginTx() ) {
     td = tx.traversalDescription();
}

td.traverse( startNode );
----

[[traversal-java-api-uniqueness]]
=== Uniqueness

Sets the rules for how positions can be revisited during a traversal as stated in `Uniqueness`.
Default if not set is `NODE_GLOBAL`.

A Uniqueness can be supplied to the `TraversalDescription` to dictate under what circumstances a traversal may revisit the same position in the graph.
The various uniqueness levels that can be used in Neo4j are:

* `NONE`: Any position in the graph may be revisited.
* `NODE_GLOBAL` uniqueness: No node in the entire graph may be visited more than once.
This could potentially consume a lot of memory since it requires keeping an in-memory data structure remembering all the visited nodes.
* `RELATIONSHIP_GLOBAL` uniqueness: no relationship in the entire graph may be visited more than once.
Just like `NODE_GLOBAL` uniqueness, this could potentially use up a lot of memory.
But since graphs typically have a larger number of relationships than nodes, the memory overhead of this uniqueness level could grow even quicker.
* `NODE_PATH` uniqueness: A node may not occur previously in the path reaching up to it.
* `RELATIONSHIP_PATH` uniqueness: A relationship may not occur previously in the path reaching up to it.
* `NODE_RECENT` uniqueness: Similar to `NODE_GLOBAL` uniqueness in that there is a global collection of visited nodes each position is checked against.
This uniqueness level does however have a cap on how much memory it may consume in the form of a collection that only contains the most recently visited nodes.
The size of this collection can be specified by providing a number as the second argument to the TraversalDescription.uniqueness()-method along with the uniqueness level.
* `RELATIONSHIP_RECENT` uniqueness: Works like `NODE_RECENT` uniqueness, but with relationships instead of nodes.

==== Example
Here is an example of a traversal using a predefined Uniqueness constraint:
----
TraversalDescription td;
try ( Transaction tx = graphDb.beginTx() ) {
     td = tx.traversalDescription();
            .uniqueness( Uniqueness.RELATIONSHIP_GLOBAL )
}

td.traverse( startNode );
----


[[traversal-java-api-branchselector]]
=== BranchSelector

A `BranchSelector` / `BranchOrderingPolicy` is used for selecting which branch of the traversal to attempt next.
This is used for implementing traversal orderings.

The traversal framework provides a few basic ordering implementations based on the link:https://en.wikipedia.org/wiki/Depth-first_search[depth-first^] and link:https://en.wikipedia.org/wiki/Breadth-first_search[breadth-first^] algorithms:

* `BranchOrderingPolicies.PREORDER_DEPTH_FIRST`: Traversing depth first, visiting each node before visiting its child nodes.
* `BranchOrderingPolicies.POSTORDER_DEPTH_FIRST`: Traversing depth first, visiting each node after visiting its child nodes.
* `BranchOrderingPolicies.PREORDER_BREADTH_FIRST`: Traversing breadth first, visiting each node before visiting its child nodes.
* `BranchOrderingPolicies.POSTORDER_BREADTH_FIRST`: Traversing breadth first, visiting each node after visiting its child nodes.

[NOTE]
====
Breadth-first traversals have a higher memory overhead than depth-first traversals.
====

A `BranchSelector` carries state and hence needs to be uniquely instantiated for each traversal.
Therefore it is supplied to the `TraversalDescription` through a `BranchOrderingPolicy` interface, which is a factory of `BranchSelector` instances.

A user of the Traversal framework rarely needs to implement his own `BranchSelector` or `BranchOrderingPolicy`, it is provided to let graph algorithm implementors provide their own traversal orders.
The Neo4j Graph Algorithms package contains for example a `BestFirst` order `BranchSelector` / `BranchOrderingPolicy` that is used in BestFirst search algorithms such as A* and Dijkstra.

==== Example
Given the following graph, these are the results of the branch ordering policies without any extra filter:

image::traversal_order_example_graph.png[align="center", role="middle", width=200]

[cols="1,1"]
|===
|Ordering policy |Order of the nodes in traversal

|`BranchOrderingPolicies.PREORDER_DEPTH_FIRST`
|a, b, d, c, e,

|`BranchOrderingPolicies.POSTORDER_DEPTH_FIRST`
|d, b, e, c, a

|`BranchOrderingPolicies.PREORDER_BREADTH_FIRST`
|a, b, c, d, e

|`BranchOrderingPolicies.POSTORDER_BREADTH_FIRST`
|d, e, b, c, a
|===

==== BranchOrderingPolicy

A BranchOrderingPolicy is a factory for creating ``BranchSelector``s to decide in what order branches are returned
(where a branch's position is represented as a `Path` from the start node to the current node).

Depth-first and breadth-first are common policies and can be accessed by the convenience methods by breadthFirst() / depthFirst().

===== Example
[source, java, role="nocopy"]
----
TraversalDescription td;
try ( Transaction tx = graphDb.beginTx() ) {
     td = tx.traversalDescription();
            .depthFirst()
}

td.traverse( startNode );
----

These are equivalent to setting the `BranchOrderingPolicies.PREORDER_BREADTH_FIRST` / `BranchOrderingPolicies.PREORDER_DEPTH_FIRST` policy.

[source, java, role="nocopy"]
----
TraversalDescription td;
try ( Transaction tx = graphDb.beginTx() ) {
     td = tx.traversalDescription();
            .order( BranchOrderingPolicies.PREORDER_BREADTH_FIRST )
}

td.traverse( startNode );
----

==== TraversalBranch

An object used by the BranchSelector to get more branches from a certain branch.
In essence these are a composite of a Path and a RelationshipExpander that can be used to get new TraversalBranches from the current one.


[[traversal-java-api-path]]
=== Path

`Path` is a general interface that is part of the Neo4j API.
In the traversal API of Neo4j the use of Paths are twofold.
Traversers can return their results in the form of the Paths of the visited positions in the graph that are marked for being returned.
Path objects are also used in the evaluation of positions in the graph, for determining if the traversal should continue from a certain point or not, and whether a certain position should be included in the result set or not.


[[traversal-java-api-pathexpander]]
=== PathExpander / RelationshipExpander

The traversal framework use the `PathExpander` (replacing `RelationshipExpander`) to discover the relationships that should be followed from a particular path to further branches in the traversal.


[[traversal-java-api-expander]]
=== Expander

This is a more generic version of relationships where a `RelationshipExpander` is injected, defining all relationships to be traversed for any given node.

The `Expander` interface is an extension of the `RelationshipExpander` interface that makes it possible to build customized versions of an `Expander`.
The implementation of `TraversalDescription` uses this to provide methods for defining which relationship types to traverse, this is the usual way a user of the API would define a `RelationshipExpander` -- by building it internally in the `TraversalDescription`.

All the RelationshipExpanders provided by the Neo4j traversal framework also implement the Expander interface.
For a user of the traversal API it is easier to implement the PathExpander/RelationshipExpander interface, since it only contains one method -- the method for getting the relationships from a path/node, the methods that the Expander interface adds are just for building new Expanders.

[[examples-how-to-use-the-traversal-framework]]
=== How to use the Traversal framework

A link:{org-neo4j-graphdb-traversal-TraversalDescription}[`org.neo4j.graphdb.traversal.TraversalDescription`^] is built using a fluent interface and such a description can then spawn several link:{org-neo4j-graphdb-traversal-Traverser}[`org.neo4j.graphdb.traversal.Traverser`^] objects.

image::traversal_framework_example.svg[role="middle"]

[NOTE]
====
The source code for the examples can be found here: link:https://github.com/neo4j/neo4j-documentation/blob/{neo4j-version}/embedded-examples/src/main/java/org/neo4j/examples/TraversalExample.java[`TraversalExample.java`^].
====

With the definition of the RelationshipTypes as:

[source, java]
----
private enum Rels implements RelationshipType
{
    LIKES, KNOWS
}
----

The graph can be traversed with for example the following traverser, starting at the node with the `name = 'Joe'`:

[source, java]
----
for ( Path position : db.traversalDescription()
        .depthFirst()
        .relationships( Rels.KNOWS )
        .relationships( Rels.LIKES, Direction.INCOMING )
        .evaluator( Evaluators.toDepth( 5 ) )
        .traverse( node ) )
{
    output += position + "\n";
}
----

The traversal will output:

[source, output, role="noheader"]
----
(0)
(0)<-[LIKES,1]-(5)
(0)<-[LIKES,1]-(5)-[KNOWS,6]->(1)
(0)<-[LIKES,1]-(5)-[KNOWS,6]->(1)<-[KNOWS,5]-(6)
(0)<-[LIKES,1]-(5)-[KNOWS,6]->(1)-[KNOWS,4]->(4)
(0)<-[LIKES,1]-(5)-[KNOWS,6]->(1)-[KNOWS,4]->(4)-[KNOWS,3]->(3)
(0)<-[LIKES,1]-(5)-[KNOWS,6]->(1)-[KNOWS,4]->(4)-[KNOWS,3]->(3)-[KNOWS,2]->(2)
----

Since a `TraversalDescription` is immutable it is also useful to create template descriptions which holds common settings shared by different traversals.
For example, start with this traverser:

[source, java]
----
friendsTraversal = db.traversalDescription()
        .depthFirst()
        .relationships( Rels.KNOWS )
        .uniqueness( Uniqueness.RELATIONSHIP_GLOBAL );
----


This traverser would yield the following output (starting from the node with the `name = 'Joe'`):

[source, java]
----
(0)
(0)-[KNOWS,0]->(2)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)<-[KNOWS,4]-(1)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)<-[KNOWS,4]-(1)<-[KNOWS,6]-(5)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)<-[KNOWS,4]-(1)<-[KNOWS,5]-(6)
----

Create a new traverser from it, restricting depth to three:

[source, java]
----
for ( Path path : friendsTraversal
        .evaluator( Evaluators.toDepth( 3 ) )
        .traverse( node ) )
{
    output += path + "\n";
}
----

This will give the following output:

[source, output, role="noheader"]
----
(0)
(0)-[KNOWS,0]->(2)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)
----


Or how about from depth two to four?
That is done like this:

[source, java]
----
for ( Path path : friendsTraversal
        .evaluator( Evaluators.fromDepth( 2 ) )
        .evaluator( Evaluators.toDepth( 4 ) )
        .traverse( node ) )
{
    output += path + "\n";
}
----

This will give the following output:

[source, output, role="noheader"]
----
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)
(0)-[KNOWS,0]->(2)<-[KNOWS,2]-(3)<-[KNOWS,3]-(4)<-[KNOWS,4]-(1)
----

For various useful evaluators, see the link:{org-neo4j-graphdb-traversal-Evaluators}[`org.neo4j.graphdb.traversal.Evaluators`^] Java API or simply implement the link:{org-neo4j-graphdb-traversal-Evaluator}[`org.neo4j.graphdb.traversal.Evaluator`^] interface yourself.

If you are not interested in the Paths, but the Nodes you can transform the traverser into an iterable of nodes like this:

[source, java]
----
for ( Node currentNode : friendsTraversal
        .traverse( node )
        .nodes() )
{
    output += currentNode.getProperty( "name" ) + "\n";
}
----

This will give the following output:

[source, output, role="noheader"]
----
Joe
Sara
Peter
Dirk
Lars
Lisa
Ed
----

Relationships are fine as well, here is an example how to get them:

[source, java]
----
for ( Relationship relationship : friendsTraversal
        .traverse( node )
        .relationships() )
{
    output += relationship.getType().name() + "\n";
}
----


[source, output, role="noheader"]
----
KNOWS
KNOWS
KNOWS
KNOWS
KNOWS
KNOWS
----